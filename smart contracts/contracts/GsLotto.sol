// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";


contract GsLotto is ReentrancyGuard, Ownable, VRFConsumerBaseV2 {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

  // Variables related to Chainlink VRF (Verifiable Random Function)
    VRFCoordinatorV2Interface COORDINATOR;              // Interface for interacting with the Chainlink VRF Coordinator

    uint64 private s_subscriptionId;
    address private vrfCoordinator = "";  // Address of the Chainlink VRF Coordinator
    bytes32 private keyHash = "";  // Key hash used for random number generation
    uint16 private requestConfirmations = 3; // Number of confirmations required for a Chainlink VRF request
    uint32 private numWords = 6;  // Number of random words generated by Chainlink VRF
    uint32 private callbackGasLimit = 2500000; // Gas limit for the Chainlink VRF callback
    address private s_owner;

// Struct to store the status and random words of a Chainlink VRF request
    struct RequestStatus {
        bool fulfilled; // whether the request has been successfully fulfilled
        bool exists; // whether a requestId exists
        uint256[] randomWords;
    }

// Mapping to track the status of Chainlink VRF requests
   mapping(uint256 => RequestStatus) public s_requests;
      uint256  public lastRequestId; 

          /**
    Lottery Settings
    */

     IERC20 paytoken;  // ERC20 token used for payments
    uint256 public currentLotteryId;
    uint256 public currentTicketId;
    uint256 public ticketPrice = 10 ether; // Price of a lottery ticket
    uint256 public serviceFee = 3000; // BASIS POINTS 3000 is 30%
    uint256 public numberWinner; // Number of winners in the lottery

// Enum to represent the status of a lottery
    enum Status {
        Open,
        Close,
        Claimable
    }

// Struct to represent a lottery
    struct Lottery {
        Status status;
        uint256 startTime;
        uint256 endTime;
        uint256 firstTicketId;
        uint256 transferJackpot;
        uint256 lastTicketId;
        uint[6] winningNumbers; // Array containing the winning numbers
        uint256 totalPayout;
        uint256 commission;
        uint256 winnerCount;
    }

// Struct to represent a ticket
    struct Ticket {
        uint256 ticketId;
        address owner;
        uint[6] chooseNumbers;
    }

    mapping(uint256 => Lottery) private _lotteries;
    mapping(uint256 => Ticket) private _tickets;
    mapping(address => mapping(uint256 => uint256[])) private _userTicketIdsPerLotteryId; // Mapping to track the ticket IDs owned by each user for each lottery
    mapping(address => mapping(uint256 => uint256)) public _winnersPerLotteryId; // Mapping to track the number of winners per lottery for each user

    event LotteryWinnerNumber(uint256 indexed lotteryId, uint[6] finalNumber);

    event LotteryClose(
        uint256 indexed lotteryId,
        uint256 lastTicketId
    );

    event LotteryOpen(
        uint256 indexed lotteryId,
        uint256 startTime,
        uint256 endTime,
        uint256 ticketPrice,
        uint256 firstTicketId,
        uint256 transferJackpot,
        uint256 lastTicketId,
        uint256 totalPayout
    );

    event TicketsPurchase(
        address indexed buyer,
        uint256 indexed lotteryId,
        uint[6] chooseNumbers
    );

  
  constructor(uint64 subscriptionId, IERC20 _paytoken) VRFConsumerBaseV2(vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        s_owner = msg.sender;
        s_subscriptionId = subscriptionId;
        paytoken = _paytoken;
    }

        function openLottery() external onlyOwner nonReentrant {
            // Increment the current lottery and ticket IDs

        currentLotteryId++;
        currentTicketId++;

        // Calculate the fund for the jackpot in the current lottery
        uint256 fundJackpot = (_lotteries[currentLotteryId].transferJackpot).add(1000 ether);

        // Declare variables for transferJackpot, totalPayout, lastTicketId, and endTime
        uint256 transferJackpot;
        uint256 totalPayout;
        uint256 lastTicketId;
        uint256 endTime;

        // Create a new Lottery struct and assign its values
        _lotteries[currentLotteryId] = Lottery({
            status: Status.Open,
            startTime: block.timestamp,
            endTime: 100,
            firstTicketId: currentTicketId,
            transferJackpot: fundJackpot,
            winningNumbers: [uint(0), uint(0), uint(0), uint(0), uint(0), uint(0)],
            lastTicketId: currentTicketId,
            totalPayout: 0,
            commision: 0,
            winnerCount: 0
        });

        // Emit an event to indicate that a new lottery has been opened
        emit LotteryOpen(
            currentLotteryId,
            block.timestamp,
            endTime,
            ticketPrice,
            currentTicketId,
            transferJackpot,
            lastTicketId,
            totalPayout
        );
    }



    function buyTickets(uint[6] calldata numbers) public payable nonReentrant {
        uint256 walletBalance = paytoken.balanceOf(msg.sender);
        require(walletBalance >= ticketPrice, "Funds not available to complete transaction");
        paytoken.transferFrom(address(msg.sender), address(this), ticketPrice);
   
        uint256 commissionFee = (ticketPrice.mul(serviceFee)).div(10000);
  
        _lotteries[currentLotteryId].commission += commissionFee;
        uint256 netEarn = ticketPrice - commissionFee;
        _lotteries[currentLotteryId].transferJackpot += netEarn;

   
        _userTicketIdsPerLotteryId[msg.sender][currentLotteryId].push(currentTicketId);
        

        _tickets[currentTicketId] = 
        Ticket({ticketId:currentTicketId,
        owner: msg.sender, 
        chooseNumbers: numbers });

        currentTicketId++;
        _lotteries[currentLotteryId].lastTicketId = currentTicketId;
        emit TicketsPurchase(msg.sender, currentLotteryId, numbers);
    }


 function closeLottery() external onlyOwner {
        require(_lotteries[currentLotteryId].status == Status.Open, "Lottery not open");
        require(block.timestamp > _lotteries[currentLotteryId].endTime, "Lottery not over");
        _lotteries[currentLotteryId].lastTicketId = currentTicketId;
        _lotteries[currentLotteryId].status = Status.Close;


        uint256 requestId;
  
     
        requestId = COORDINATOR.requestRandomWords(
        keyHash,
        s_subscriptionId,
        requestConfirmations,
        callbackGasLimit,
        numWords
        );
        s_requests[requestId] = RequestStatus({
            randomWords: new uint256[](0),
            exists: true,
            fulfilled: false
        });
        lastRequestId = requestId;
        emit LotteryClose(currentLotteryId, currentTicketId);
    }

   function drawNumbers() external onlyOwner nonReentrant () {
        require(_lotteries[currentLotteryId].status == Status.Close, "Lottery not close");
        uint256[] memory numArray = s_requests[lastRequestId].randomWords;
          uint num1 = numArray[0] % 10;
          uint num2 = numArray[1] % 10;
          uint num3 = numArray[2] % 10;
          uint num4 = numArray[3] % 10;
          uint num5 = numArray[4] % 10;
          uint num6 = numArray[5] % 10;
          uint[6] memory finalNumbers = [num1, num2, num3, num4, num5, num6];
          for (uint i = 0; i < finalNumbers.length; i++){
                if (finalNumbers[i] == 0) {
                    finalNumbers[i] = 1;
                }
          }
       _lotteries[currentLotteryId].winningNumbers = finalNumbers;
       _lotteries[currentLotteryId].totalPayout = _lotteries[currentLotteryId].transferJackpot;
   }

    function sortArrays(uint[6] memory numbers) internal pure returns (uint[6] memory) {
            bool swapped;
        for (uint i = 1; i < numbers.length; i++) {
            swapped = false;
            for (uint j = 0; j < numbers.length - i; j++) {
                uint next = numbers[j + 1];
                uint actual = numbers[j];
                if (next < actual) {
                    numbers[j] = next;
                    numbers[j + 1] = actual;
                    swapped = true;
                }
            }
            if (!swapped) {
                return numbers;
            }
        }
        return numbers;
    }

      function countWinners(uint[6] memory array, uint256 _lottoId) external onlyOwner {
       require(_lotteries[_lottoId].status == Status.Close, "Lottery not close");
       require(_lotteries[_lottoId].status != Status.Claimable, "Lottery Already Counted");
       delete numberWinner;
       uint256 firstTicketId = _lotteries[_lottoId].firstTicketId;
       uint256 lastTicketId = _lotteries[_lottoId].lastTicketId;
       uint[6] memory winOrder;
       winOrder = sortArrays(array);
       bytes32 encodeWin = keccak256(abi.encodePacked(winOrder));
       uint256 i = firstTicketId;
        for (i; i < lastTicketId; i++) {
            address buyer = _tickets[i].owner;
            uint[6] memory userNum = _tickets[i].chooseNumbers;
            bytes32 encodeUser = keccak256(abi.encodePacked(userNum));
              if (encodeUser == encodeWin) {
                  numberWinner++;
                  _lotteries[_lottoId].winnerCount = numberWinner;
                  _winnersPerLotteryId[buyer][_lottoId] = 1;
              }
        }
        if (numberWinner == 0){
            uint256 nextLottoId = (currentLotteryId).add(1);
            _lotteries[nextLottoId].transferJackpot = _lotteries[currentLotteryId].totalPayout;
        }
    _lotteries[currentLotteryId].status = Status.Claimable;
   }

     function claimPrize(uint256 _lottoId) external nonReentrant {
        require(_lotteries[_lottoId].status == Status.Claimable, "Not Payable");
        require(_lotteries[_lottoId].winnerCount > 0, "Not Payable");
        require(_winnersPerLotteryId[msg.sender][_lottoId] == 1, "Not Payable");
        uint256 winners = _lotteries[_lottoId].winnerCount;
        uint256 payout = (_lotteries[_lottoId].totalPayout).div(winners);
        paytoken.safeTransfer(msg.sender, payout);
        _winnersPerLotteryId[msg.sender][_lottoId] = 0;
   }


  function getRequestStatus(
    ) external view returns (bool fulfilled, uint256[] memory randomWords) {
        require(s_requests[lastRequestId].exists, "request not found");
        RequestStatus memory request = s_requests[lastRequestId];
        return (request.fulfilled, request.randomWords);
    }


    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        require(s_requests[_requestId].exists, "request not found");
        s_requests[_requestId].fulfilled = true;
        s_requests[_requestId].randomWords = _randomWords;
    }

    /**
    Lottery additional functions.
     */

   function viewTickets(uint256 ticketId) external view returns (address, uint[6] memory) {
        address buyer;
        buyer = _tickets[ticketId].owner;
        uint[6] memory numbers;
        numbers = _tickets[ticketId].chooseNumbers;
        return (buyer, numbers);
    }

    function viewLottery(uint256 _lotteryId) external view returns (Lottery memory) {
        return _lotteries[_lotteryId];
    }

    function getBalance() external view onlyOwner returns(uint256) {
        return paytoken.balanceOf(address(this));
    }

    function fundContract(uint256 amount) external onlyOwner {
        paytoken.safeTransferFrom(address(msg.sender), address(this), amount);
    }

    function withdraw() public onlyOwner() {
      paytoken.safeTransfer(address(msg.sender), (paytoken.balanceOf(address(this))));
    }

}